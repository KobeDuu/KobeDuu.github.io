<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>操作系统学习笔记 | KobeDuu</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://kobeduu.github.io/favicon.ico?v=1624698162368">
<link rel="stylesheet" href="https://kobeduu.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="1. 操作系统

操作系统是管理计算机硬件和软件资源的程序。


系统态
系统态运行的程序可以访问计算机的任务资源。
用户态
执行用户程序，当发生系统调用、中断、异常时就会进入系统态。

2. 进程和线程的区别

进程是资源分配的最小单位
..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://kobeduu.github.io">
        <img src="https://kobeduu.github.io/images/avatar.png?v=1624698162368" class="site-logo">
        <h1 class="site-title">KobeDuu</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://kobeduu.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">操作系统学习笔记</h2>
            <div class="post-date">2020-10-23</div>
            
            <div class="post-content" v-pre>
              <h2 id="1-操作系统">1. 操作系统</h2>
<blockquote>
<p>操作系统是管理计算机硬件和软件资源的程序。</p>
</blockquote>
<ul>
<li><strong>系统态</strong><br>
系统态运行的程序可以访问计算机的任务资源。</li>
<li><strong>用户态</strong><br>
执行用户程序，当发生系统调用、中断、异常时就会进入系统态。</li>
</ul>
<h2 id="2-进程和线程的区别">2. 进程和线程的区别</h2>
<ul>
<li>进程是资源分配的最小单位</li>
<li>线程是 CPU 调度的最小单位</li>
<li>一个进程可以有多个线程，线程共享进程的内存空间，线程的上下文切换更快。</li>
</ul>
<h2 id="3-进程间的通信方式">3. 进程间的通信方式</h2>
<p><img src="https://kobeduu.github.io/post-images/1603436466579.png" alt="" loading="lazy"><br>
<strong>管道</strong>：实质是一个缓冲区，进程以先进先出的方式存取数据，它是半双工的，数据只能以无格式的字节流的形式向一个方向流动。</p>
<h3 id="31-匿名管道">3.1 匿名管道</h3>
<p>用于具有亲缘关系的进程之间的通信。</p>
<h3 id="32-有名管道">3.2 有名管道</h3>
<p>提供了一个路径名与之关联，使得没有亲缘关系的进程间也能通信。</p>
<h3 id="33-消息队列">3.3 消息队列</h3>
<p>存放在内核中的消息链表，每个消息体都有大小限制，用户可以自定义数据格式，克服了管道通信的无格式。</p>
<h3 id="34-共享内存">3.4 共享内存</h3>
<p>实质是多个进程拿出一块虚拟地址空间映射到同一块物理内存，这样就可以直接读写同一块内存，避免了数据的拷贝，从而大大提高了效率；需要依靠信号量来达到进程间的同步和互斥。</p>
<h3 id="35-信号量">3.5 信号量</h3>
<p>信号量表示资源的数量，初始等于1为互斥信号量。</p>
<ul>
<li><strong>P 操作</strong><br>
S -= 1，若 S &gt;= 0，程序正常执行，否则进入等待队列。</li>
<li><strong>V 操作</strong><br>
S += 1，若 S &lt;= 0，唤醒等待队列中的进程。</li>
</ul>
<h3 id="36-信号">3.6 信号</h3>
<p>是进程间通信机制中唯一的异步通信机制，可以在任何时候发送信号给另一进程。</p>
<h3 id="37-socket">3.7 Socket</h3>
<p>可以实现跨网络不同主机上的进程之间的通信。</p>
<h2 id="4-线程间同步的方式">4. 线程间同步的方式</h2>
<h3 id="41-互斥量">4.1 互斥量</h3>
<p>保证同一时刻只有一个线程访问临界资源。</p>
<h3 id="42-信号量">4.2 信号量</h3>
<p>控制同一时刻访问资源的最大线程数量。</p>
<h3 id="43-事件">4.3 事件</h3>
<p>Wait/Notify 机制。</p>
<h2 id="5-进程调度算法">5. 进程调度算法</h2>
<ul>
<li><strong>先到先服务</strong></li>
<li><strong>短作业优先</strong></li>
<li><strong>时间片轮转</strong></li>
</ul>
<h2 id="6-内存管理机制">6. 内存管理机制</h2>
<h3 id="61-页式管理">6.1 页式管理</h3>
<p>把主存划分为大小相等且固定的一页一页的形式，通过页表对应逻辑地址和物理地址，提高了内存利用率，便于系统管理。</p>
<h3 id="62-段式管理">6.2 段式管理</h3>
<p>不同于页式管理，段式管理中段的大小不固定，由程序决定，每一段也具有逻辑意义，数据段、主程序段等。</p>
<h3 id="63-段页式管理">6.3 段页式管理</h3>
<p>先分段再分页。</p>
<h2 id="7-虚拟内存">7. 虚拟内存</h2>
<blockquote>
<p>为进程定义了一段连续的虚拟地址空间，实现了进程隔离，使得计算机能够运行大于物理内存的程序。</p>
</blockquote>
<h2 id="8-页面置换算法">8. 页面置换算法</h2>
<ul>
<li><strong>FIFO</strong><br>
先进先出淘汰算法，总是淘汰最先进入内存的页面。</li>
<li><strong>LFU</strong><br>
最少使用淘汰算法，总是淘汰之前最少使用的页面。</li>
<li><strong>LRU</strong><br>
最近最久未使用淘汰算法，总是淘汰最久未使用的页面。</li>
</ul>
<pre><code class="language-java">class LRUCache {
    private int capacity;
    private HashMap&lt;Integer, ListNode&gt; map = new HashMap&lt;&gt;();
    private ListNode head = new ListNode(null, null, -1, -1);
    private ListNode tail = new ListNode(null, null, -1, -1);
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        head.next = tail;
        tail.pre = head;
    }

    public int get(int key) {
        ListNode node = map.get(key);
        if(node == null){
            return -1;
        } else {
            deleteNode(node);
            addNode(node);
            return node.val;
        }
    }

    public void put(int key, int value) {
        ListNode node = map.get(key);
        if(node != null){
            deleteNode(node);
            node.val = value;
        } else {
            node = new ListNode(null, null, key, value);
            map.put(key, node);
        }
        addNode(node);
        if(map.size() &gt; capacity){
            node = tail.pre;
            deleteNode(node);
            map.remove(node.key);
            node = null;
        }
    }

    private void deleteNode(ListNode node) {
        ListNode nodePre = node.pre;
        ListNode nodeNext = node.next;
        nodePre.next = nodeNext;
        nodeNext.pre = nodePre;
    }

    private void addNode(ListNode node) {
        ListNode headNext = head.next;
        head.next = node;
        headNext.pre = node;
        node.pre = head;
        node.next = headNext;
    }

    private class ListNode{
        public ListNode pre;
        public ListNode next;
        public int key;
        public int val;
        public ListNode(ListNode pre, ListNode next, int key, int val) {
            this.pre = pre;
            this.next = next;
            this.key = key;
            this.val = val;
        }
    }
}
</code></pre>
<h2 id="7-io-多路复用">7. IO 多路复用</h2>
<h3 id="71-select">7.1 select</h3>
<ul>
<li>select 支持监控的文件描述符数量太小。</li>
<li>select 每次调用都需要把文件描述符拷贝到内核中，这会产生巨大的开销。</li>
<li>select 采用轮询的方式监控文件描述符，文件描述符数量越大，性能越差。</li>
</ul>
<h3 id="72-poll">7.2 poll</h3>
<ul>
<li>poll 没有最大文件描述符数量的限制。</li>
</ul>
<h3 id="73-epoll">7.3 epoll</h3>
<ul>
<li>epoll 和内核共享一块内存，通过调用 epoll_ctl 操作状态变化的文件描述符。</li>
<li>内核中注册的文件描述符有一个回调函数，调用后会加入就绪队列，调用 epoll_wait 返回就绪队列的事件。</li>
<li><strong>LT 与 ET 模式的区别</strong><br>
LT 模式下，只要 fd 还有数据可读，每次调用 epoll_wait 都会返回它的事件，提醒用户程序去操作，ET 模式只会提示一次。</li>
</ul>

            </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://kobeduu.github.io/post/sui-bi/">
                  <h3 class="post-title">
                    理性的思考
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>



  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css" integrity="sha384-9tPv11A+glH/on/wEu99NVwDPwkMQESOocs/ZGXPoIiLE8MU/qkqUcZ3zzL+6DuH" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.js" integrity="sha384-U8Vrjwb8fuHMt6ewaCy8uqeUXv4oitYACKdB0VziCerzt011iQ/0TqlSlv8MReCm" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/contrib/auto-render.min.js" integrity="sha384-aGfk5kvhIq5x1x5YdvCp4upKZYnA8ckafviDpmWEKp4afOZEqOli7gqSnh8I6enH" crossorigin="anonymous"></script>
<script>
    renderMathInElement(document.body,
   {
              delimiters: [
                  {left: "$$", right: "$$", display: true},
                  {left: "$", right: "$", display: false}
              ]
          }
  );
</script>




  </body>
</html>
